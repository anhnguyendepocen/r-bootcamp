---
title: "Functions and Iterative Programming"
author: "MC"
date: "August 14, 2015"
output:   
    ioslides_presentation:
      highlight: zenburn
      smaller: yes
      theme: readable
      widescreen: no
      css: mainPresentation.css
---

## Outline
Functions

- Review of using
- Writing your own

Control Flow & Iterative Programming

- Standard looping
- Vectorized approaches
- Parallelizing



# Using functions
## Using functions

Functions are extremely important in the R world.

- they are themselves objects and can be used as such

The key thing to remember is that functions (almost always) take specific inputs and always return a value

Every R helpfile states explicitly the syntax required to use a function

The basic components

- argument list
- body
- environment


## Arguments

Note that not all arguments are required, and some will have default values.

It is important to know the arguments of any function you use, or you might be missing out on quite a bit, or not understand why you're getting an error.

As an example, examine the arguments for the mean function (i.e. type ?mean for the help file)

<img src='images/meanHelpfile.png' width=500>


## Body

The body of a function is where all the code that works on those arguments

Type median.default at your console to see the body of median, which is fairly simple as far as functions go.

```{r median, cache=TRUE}
median.default
```


## Body
Note that many of R's core functions actually call other functions that are written in C for faster computation.

If they are written well, you will typically see much of the first part devoted to error checking.

A good way to start learning decent coding style is by looking at code from base R functions.


## Environment

The environment is the frame or map of the location of the function's variables.

Its purpose is primarily to bind names to a set of values

What do you think the last line will produce?

```{r enviro, eval=FALSE}
b = 3

f = function(b){
  return(b)
}

f(2)

f = function(){
  return(b)
}
f()
```

## Environment

In the first case, the reason 2 is returned instead of 3 is because the first environment searched to locate b is the the one created by the function.

In the second case, b is not found in the current (function) environment, so the global environment is searched.

```{r, cache=TRUE, results='hold'}
f = function(){
  print(environment())
  # return(b)
}
f(); environment()
```

This will be more important when writing your own functions, and more so if you create your own package.

However, it's important to at least be aware of environments to better understand how functions are working when you use them.


# Writing your own functions
## Writing your own functions
Once you get the hang of R, you'll want to write your own functions to further make your data wrangling and exploration efficient.  

Furthermore, functions aid reproducibility.

A simple rule is, if you've written the same line of code more than twice, you should probably write a function the does the operation you're attempting.

## Writing your own functions
And it doesn't have to be complicated.  Functions (typically) take <mark class='emp'>arguments</mark> and return <mark class='emp'>values</mark>.

## Anonymous functions

```{r}
posNeg = function(x){
  result = ifelse(sum(x) > 0, 'Positive', 'Negative')
  return(result)
}

randomData = rnorm(10)
posNeg(x=randomData)
```

And Rstudio's debugger makes also makes testing very easy.




# Iterative Programming
## Iterative Programming
Data manipulation involves a lot of repeated operations, and R shines in this area in that it makes a lot of this easier.

The typical approach seen in other languages can be used, and sometimes is still the way to go.

Column means:
```{r loop, cache=T}
# million column matrix
d = matrix(rnorm(10000000), nrow=10)    # might take a second or two
dmeans = vector('numeric', ncol(d))     # not necessary but does speed up explicit loops

# The following may take up to ~ 10 seconds
for (i in 1:ncol(d)){
  dmeans[i] = mean(d[,i])
}
```

## Iterative Programming
However, other approaches are available, and some vectorized operations can reduce code and are often faster. The quicker you learn the <mark class='empCode'>apply</mark> family of functions, as well as related versions in the aforementioned plyr package, the quicker your data processing will be.

Apply the <mark class='empCode'>mean</mark> function to the columns.  Similar time as a loop in this case but cleaner code. They also have parallelized versions meaning that their speed can be increased quite a bit.

```{r apply, cache=T}
dmeans = apply(d, 2, mean) # the 2 specifies columns
```

Faster.
```{r colMeans, cache=T}
dmeans = colMeans(d)
```

## Iterative Programming
The vectorized approach works in a lot of other places also.

```{r vectorize, cache=T, results='hold'}
myvar = 1:100
myvar[sample(myvar, 50)] = NA  # insert 50 missing values
sum(is.na(myvar))
myvar[is.na(myvar)] = 0  # change missing to 0
any(is.na(myvar))

1:10 >= 5  # which of the sequence 1:10 is greater or equal to 5

rowSums(d > 0)  # count values greater than zero for each row
```

# Your turn
## Your turn

Using either matrix below (or both), perform a row or column operation with two different approaches.

Suggestions: 

  - Calculations like <mark class='empCode'>rowMeans</mark>, <mark class='empCode'>colSums</mark>
  - Operators <mark class='empCode'>== != > < </mark>
  - <mark class='empCode'>any</mark> <mark class='empCode'>which</mark> <mark class='empCode'>all</mark>


```{r}
nums = matrix(sample(1:3, 9, replace = T), 3, 3)
lets = matrix(letters[1:9], 3, 3)
```

